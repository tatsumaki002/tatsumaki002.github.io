<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>RangeAMP</title>
      <link href="/2020/07/27/dos/"/>
      <url>/2020/07/27/dos/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>RangeAMP是针对CDN的DOS攻击方式之一，算是比较前沿的研究了，特此记录。</p><p>在RangeAMP中涉及到如下几个关键词：CDN，HTTP Range request，ddos，放大攻击</p><h1 id="关键词"><a href="#关键词" class="headerlink" title="关键词"></a>关键词</h1><h2 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h2><p>第一个关键词：什么是CDN？</p><p>CDN，内容分发网络。一般来说，CDN服务商会在全国各地建立CDN节点，用户访问时，就会访问距离最近的CDN节点，达到最快的访问效果。</p><p>比如一个网站选择了CDN服务商，举例阿里云。那么阿里云会将网站上的部分内容缓存到所有CDN节点上。CDN节点最重要的功能就是缓存，但是CDN节点的存储空间不会无限大，因此需要使用动态缓存算法。即：如果一个用户访问web服务器上的某个资源，而CDN节点没有这个资源。那CDN节点就会向web服务器去请求，下发给用户的同时保存这个资源在CDN节点上。</p><p>关键点在于：CDN节点的存储空间不会无限大，那么就需要用到缓存替换算法，把一些不需要用到的资源删除。不过这样一来，如果有用户去请求这个资源，需要反复从服务器请求资源，这就是攻击的必要条件。</p><h2 id="HTTP-Range-Request-HTTP范围请求"><a href="#HTTP-Range-Request-HTTP范围请求" class="headerlink" title="HTTP Range Request HTTP范围请求"></a>HTTP Range Request HTTP范围请求</h2><p>对于没有使用CDN的web服务器而言，客户端请求多大的资源，下载时间就是多长，如果想要节省时间的话，除了提高网速的办法就是启用多线程。<br>如果使用HTTP通信的话，web服务器得开启对HTTP范围请求的支持，客户端发起请求的时候可以在数据包里添加这些东西：<br>Range: bytes=start-end<br>来指定下载的内容。<br>而网站在接收到相应信息之后，如果不支持，那么就会忽略，返回200<br>如果支持：<br>有效的话，返回206<br>无效或者超出边界，返回416</p><h2 id="DDOS"><a href="#DDOS" class="headerlink" title="DDOS"></a>DDOS</h2><p>分布式拒绝服务。简单点，就是利用大量的资源去请求服务器，导致服务器停止响应。<br>DDOS主要分为两类：<br>1.资源消耗，比较典型的DOS攻击，针对tcp和udp协议的ddos都属于这一类。通过大量的请求消耗带宽，从而让服务器卡死。<br>服务消耗，这个是让服务端始终保持在处理高消耗型的业务的忙碌状态中，使得无法对正常业务进行响应。针对DNS、DHCP或者是HTTP服务器的大量请求都属于这类。</p><h2 id="放大攻击"><a href="#放大攻击" class="headerlink" title="放大攻击"></a>放大攻击</h2><p>利用的是一种请求和响应流量不对称的方式来进行攻击，比如攻击者发送10k的请求，消耗掉的目标带宽就只有10k。但是如果有一台设备，攻击者发送10k的请求，却能得到1000k的应答，那么攻击者就可以利用这个设备实现放大攻击。应答请求源地址改为攻击目标，这样攻击目标就会受到放大攻击<br>也就是攻击者-&gt;请求设备-&gt;设备放大了1000k-&gt;请求服务器。这样服务器就消耗了1000k的带宽。</p><h1 id="CDN和HTTP-Range-Request（HTTP范围请求）的结合"><a href="#CDN和HTTP-Range-Request（HTTP范围请求）的结合" class="headerlink" title="CDN和HTTP Range Request（HTTP范围请求）的结合"></a>CDN和HTTP Range Request（HTTP范围请求）的结合</h1><p>作者团队表示国内大厂的CDN基本都支持范围请求，而在转发上，基本为大致三个方式：<br>惰性：不进行任何修改直接转发<br>删除：直接删除Range header<br>扩展：将原请求的内容扩展到更大的字节范围中去。<br>而且大多数CDN倾向于后两种，因为客户端可能会继续请求相同资源的其他字节范围，这样优化了缓存，减少了访问延迟，并且防止了过多的回源请求。<br>回源请求：指CDN对源服务器的请求。<br>对于存在多个小范围的范围请求，或者是存在两个以上重叠范围的请求，RFC7233建议是h忽略、合并或者拒绝，然而有不少CDN忽略了这个建议。<br>这就导致了问题的产生。<br>如果CDN采用删除和扩展的策略的话，这两种策略会要求CDN从源服务器上检索比客户端请求内容更多的字节，CDN只返回，然后不考虑是否重叠，那么CDN发送的响应可能要比来自源服务器的响应大数千倍，这就导致了客户端到源服务器的流量差异。<br>这种流量差异会导致流量放大攻击，称为基于范围的放大攻击（RangeAMP）</p><h1 id="攻击手法"><a href="#攻击手法" class="headerlink" title="攻击手法"></a>攻击手法</h1><blockquote><p>第一种攻击路线：小字节范围攻击（SBR）<br>攻击者-&gt;CDN-&gt;源服务器<br>这个途径中，如果CDN采用了删除或者拓展策略处理范围请求，那么攻击者可以创建一个小字节的范围头发起RangeAMP攻击，这种攻击被称为小字节范围（SBR）攻击。<br>比如攻击者只向CDN请求了图片的一小部分，但是CDN会去像源站请求更多或者是整张图片的内容，从而产生更大的流量。然后攻击者尽可能去请求CDN缓存中不存在的内容，这样攻击者的一小部分流量，CDN会向源站请求更多的流量，这样就放大了流量。</p></blockquote><blockquote><p>第二种攻击路线：重叠字范围攻击（OBR）<br>与SBR的原理不同，OBR攻击利用了多范围请求，类似的攻击方式曾经出现过，编号是CVE-2011-3192，攻击者通过向apache服务器发送多范围请求从而耗尽目标服务器的内存资源。<br>理论上，一旦带上N个range请求，那么apache服务器的压力就是n倍。<br>攻击者-&gt;FCDN-&gt;BCDN-&gt;源服务器<br>当一些CDN忽略了RFC协议时，就产生了这个漏洞。如果FCDN直接将请求转发给BCDN，而此时BCDN对请求不检查是否范围重叠，那BCDN就会起到一个类似放大的作用，去请求源服务器。而攻击者可以设置一个小型TCP接口，确认自己接收很少的数据，而不受放大攻击影响。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> DOS攻击 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DOS攻击 </tag>
            
            <tag> 网络安全前沿 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>逻辑漏洞——任意用户密码重置相关</title>
      <link href="/2020/07/12/logic-re/"/>
      <url>/2020/07/12/logic-re/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>个人以为，从逻辑漏洞开始挖掘SRC是一个不错的选择。早就在freebuf上将大佬文章收藏，等待之后阅读。</p><p>结果这一等遥遥无期，为了治好拖延症，开始阅读大佬文章并进行技术笔记的整理、发布。</p><p>一般来说，在挖src的时候，比较容易挖出来的是逻辑漏洞。逻辑漏洞也主要是看个人的思维合攻击面宽度。</p><p>这里稍微整理了一些任意用户密码重置以及攻击账号常见手法，笔记来源于Freebuf大神的文章，在这是个人对文章的一些整理和理解，想查看原文可通过如下链接：</p><p><a href="https://www.freebuf.com/articles/web/160883.html" target="_blank" rel="noopener">https://www.freebuf.com/articles/web/160883.html</a></p><h1 id="任意用户密码重置"><a href="#任意用户密码重置" class="headerlink" title="任意用户密码重置"></a>任意用户密码重置</h1><p>这个漏洞常出现的地方有：</p><p>新用户注册界面、忘记密码界面、登录后重置密码界面</p><h2 id="漏洞成因"><a href="#漏洞成因" class="headerlink" title="漏洞成因"></a>漏洞成因</h2><p>一般来说，密码找回逻辑含有用户名、用户ID、cookie；接收端：手机、邮箱；凭证：验证码、token、当前步骤这四步。</p><p>四个要素没有完整关联的话，都可能产生任意密码重置漏洞。</p><h2 id="验证码回显"><a href="#验证码回显" class="headerlink" title="验证码回显"></a>验证码回显</h2><p>在抓包发送的时候，验证码会回显到响应包中，再通过爆破用户名，就可以重置任意用户的密码。</p><h2 id="邮件token的构造"><a href="#邮件token的构造" class="headerlink" title="邮件token的构造"></a>邮件token的构造</h2><p>邮件找回密码的时候，抓包可能会显示验证用的token信息。</p><p>这里的验证方法可以抓包查看是否存在，然后对比发送到邮件的重置链接，查看是否存在关联。</p><p>如果可以直接用的话，就可通过构造链接，重置任意账号的密码。</p><h2 id="接收端会被篡改"><a href="#接收端会被篡改" class="headerlink" title="接收端会被篡改"></a>接收端会被篡改</h2><p>这里分两种情况：</p><p>1）请求包包含参数。一个简单的例子，就是通过手机方式找回验证码。接着抓包，将手机号码修改为攻击者手机来获取验证码，之后正常操作。</p><p>2）请求包通过后端绑定的号码进行验证。简而言之，在重置密码的时候是以目标账户进行重置。接着会进行身份验证，</p><p>此时是通过账号绑定的号码进行验证，请求时将账号参数修改为攻击者参数，这样发送验证码的时候就会发送到攻击者账号所绑定的手机号上。</p><p>总结：这两种攻击方式可绕过都是因为验证码与账户未绑定导致的。</p><h2 id="Cookie混淆"><a href="#Cookie混淆" class="headerlink" title="Cookie混淆"></a>Cookie混淆</h2><p>建议看原文，下面评论有些问题和解答/</p><p><a href="https://www.freebuf.com/articles/web/162152.html" target="_blank" rel="noopener">https://www.freebuf.com/articles/web/162152.html</a></p><p>一般来说，在重置密码的时候，页面逻辑往往是-&gt;输入要重置的账号-&gt;验证身份-&gt;重置密码</p><p>在重置密码这个页面，服务端该如何确认要重置的密码账户呢？</p><p>如果是通过cookie中的值来确定的话，就有可能存在cookie混淆的问题。</p><p>操作如下：</p><p>按照正常流程，到最后输入新密码页面时，先不管。</p><p>接着另开一个页面，输入想要重置的账号。到验证界面后，回到第一个页面，提交新密码上传。</p><p>接着使用重置的账号和设置的密码可以登录页面，这就是cookie混淆</p><h2 id="新密码提交时用户混淆"><a href="#新密码提交时用户混淆" class="headerlink" title="新密码提交时用户混淆"></a>新密码提交时用户混淆</h2><p>就是在提交新密码的时候，将用户名修改为其他人的用户名。</p><p>这里有个拓展文章，是在freebuf上意外看到的。</p><p><a href="https://www.freebuf.com/vuls/239483.html" target="_blank" rel="noopener">https://www.freebuf.com/vuls/239483.html</a></p><p>我的理解是，这个漏洞也是接收端的篡改。重置密码请求时，将用户名（对应这儿的手机号）替换成其他用户名（手机号），进行修改。</p><p>不同点在于，这里的请求是经过了加密的。</p><p>我认为此处作者能挖出洞关键在于：首先通过经验判断出了是RSA加密，且在源代码中多个js脚本含有“RSA”名称，于是联想到这是客户端加密。</p><p>通过前台调用rsa函数方法，可以直接指定账号进行加密，然后提交修改过的用户名，成功重置密码。</p><p>阅读的时候有这么一个问题：为什么不直接拿其他账号用户名加密后的参数替换呢？</p><p>且在原文中作者也尝试过，但是失败了。</p><p>查阅资料后发现，RSA加密，虽然加密函数是一样的，但是某些填充值不一定相同。</p><p>比如以会话参数作填充值的话，每次刷新页面，加密串都不一样，也就导致了不能直接拿来利用。</p><h2 id="篡改带token的重置链接中的用户名"><a href="#篡改带token的重置链接中的用户名" class="headerlink" title="篡改带token的重置链接中的用户名"></a>篡改带token的重置链接中的用户名</h2><p>在带token的重置链接中可能出现用户名id（可能经过加密等一系列措施），然后对用户名id进行修改，就可以重置任意其他用户。</p><p>在本篇文章中，出现了一个REST风格。</p><p>经过查阅资料后，REST风格大致是/user/100这种类型，其中100是user的id。</p><p>这里存在一个拓展，REST风格下的几个安全问题。</p><p>参考原文：<a href="https://blog.csdn.net/jackyrongvip/article/details/84834058" target="_blank" rel="noopener">https://blog.csdn.net/jackyrongvip/article/details/84834058</a></p><p>REST风格常见的安全漏洞：<br>1）REST第一个典型的安全漏洞，就是对用户ID没有校验，使得可以通过遍历ID查看到其他用户的信息。</p><p>一般来说，只出现一个资源的时候都已经做了安全防御。但是出现多个资源的时候就不一定了。</p><p>比如订单链接，/user/100/orders/1，对1进行遍历，说不定可以查看所有订单，甚至进行操作。</p><p>2）这个文章说的是HTTP安全响应，以及他们对应的一些功能。</p><p>X-Frame-Options：防点击劫持，其中deny告诉浏览器，不要将当前响应内容在html frame中显示出来。</p><p>3）REST会推断响应的内容是不是脚本，且不会管content-type类型，如果推断出是脚本的话，那就会直接按照脚本来执行。</p><p>修复建议：添加X-Content-Type-Options可以使其严格按照content-type中的类型来执行格式。</p><p>4）信息泄露</p><p>前后端分离的时候，会以json作为传输数据的载体，有时候json会返回多余信息，造成信息泄露。</p><p>5）可能会存在短信轰炸</p><h2 id="验证码未校验"><a href="#验证码未校验" class="headerlink" title="验证码未校验"></a>验证码未校验</h2><p>验证码说得比较笼统，根据找回密码的验证大致可以分为两类。一类是验证码，另一类就是密保问题。</p><p>第一种场景应用方式：带token的链接服务端未进行验证。简单地说，就是验证的key完全没有效果，任意输都行。</p><p>第二种场景：对所有的用户名进行遍历，里边一般会有三种情况：存在且设置了密保的，存在但没设置密保，没这个用户。</p><p>可以爆破出用户名出来，然后对未设置密保的用户进行密码重置。</p><h2 id="验证码爆破"><a href="#验证码爆破" class="headerlink" title="验证码爆破"></a>验证码爆破</h2><p>顾名思义，当验证码长度不算长的时候，而且没限制高频登录的话，就可以进行爆破。</p><p>这里可以使用burp的进阶工具turbo intruder，相关文章介绍链接在这：</p><p><a href="https://www.secpulse.com/archives/126527.html" target="_blank" rel="noopener">https://www.secpulse.com/archives/126527.html</a></p><p>具体的会新开一篇进行记录。</p><p>顺带，在爆破中如果ip受限的话，有几个方法可以解决：伪造ip、使用代理池。</p><p>伪造IP的话，根据网站服务端验证客户端IP首部的方式，可以用burp自动生成。</p><p>比如，在请求首部添加：X-Forwarded-For：128.64.$32$.$22$,最后两个字段设置成了枚举变量，就有了整个B段的随机IP。</p><p>至于代理池的话，可以使用免费的代理池服务，用脚本调用curl发起http请求，设置–proxy参数指定代理ip</p><h2 id="更改应答值"><a href="#更改应答值" class="headerlink" title="更改应答值"></a>更改应答值</h2><p>有的时候，服务器校验了验证码正确之后，会将结果状态值下发客户端，后续的步骤则依靠前端js判断是否可进入第三步。</p><p>这个时候，修改应答包的状态值，就可以进入重置密码界面。</p><h2 id="token可预测"><a href="#token可预测" class="headerlink" title="token可预测"></a>token可预测</h2><p>通过邮箱找回密码的时候，邮件中一般会附带一个含有token的重置url。</p><p>这个token就是重置凭证。只不过开发人员习惯以时间戳、递增序号、关键字段作为部分，采用某种加密算法或编码生成。</p><p>要预测这个token，就可以基于收集到的账号等关键信息，用常见的加密算法计算一遍，就能判断是否可以预测token了。</p><p>作者用了两个案例，其中第一个案例是一道CTF赛题，解题思路如下：</p><p>重置链接中存在一个key，这个key显然就是重置token。对其进行md5解密得到一串时间戳明文。</p><p>那么攻击方式如下：</p><p>攻击者账户重置，得到url时间戳-&gt;攻击者重置admin，无法得到时间戳-&gt;攻击者再此重置自身账户，得到重置时间戳。</p><p>那么admin对应的时间戳就在这两个时间戳区间，对其进行爆破即可。</p><p>第二个案例：基于递增序号的token</p><p>这个就是token会按照一定规律递增，对重置邮件的token多关注比较即可。</p><p>第三个案例：所举的案例都是token经过MD5加密而成。比如MD5（手机号+验证码），token根据关键字段组合加密而成。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>以上就是大佬文章中对于任意用户密码重置这个逻辑漏洞的总结以及自身的一些记录。总的来说，逻辑漏洞多种多样，还是需要不断的积累与视角的开阔还有长期的练习。对常见的加密形式也应有了解，DES\AES\RSA\MD5等等……</p>]]></content>
      
      
      <categories>
          
          <category> 技术笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 逻辑漏洞 </tag>
            
            <tag> SRC挖掘 </tag>
            
            <tag> 技术笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MISC题相关帮助工具</title>
      <link href="/2020/06/12/water/"/>
      <url>/2020/06/12/water/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本着水文（划掉）想要开启其他能力的心思，去做了CTF的MISC相关的题。</p><p>之前也有接触过MISC题型，大多题型涉及到crypto，不过比crypto简单多了就是。</p><h2 id="CTF"><a href="#CTF" class="headerlink" title="CTF"></a>CTF</h2><p>在历经了无数道签到题让我喜笑颜开之后，碰到了这个题目。</p><p><img src="1.png" alt="题目"></p><p>凭借着经验，一眼就看出这是一个凯撒密码的加密。然后就要对凯撒密码进行破解。</p><p>这里使用了米斯特安全团队的相关工具。</p><p><img src="2.png" alt="工具界面"></p><p>行了，找到了。</p><p><img src="3.png" alt="flag"></p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>本篇水文主要就介绍了米斯特安全团队的这个工具，无了。</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> MISC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CVE-2018-12613复现 PHPMyAdmin后台文件包含</title>
      <link href="/2020/06/11/phpmyadmin1/"/>
      <url>/2020/06/11/phpmyadmin1/</url>
      
        <content type="html"><![CDATA[<ul><li>漏洞复现</li></ul><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今天依然有些累，最近很容易困乏。依然是一篇水文。</p><p>在墨者逛靶场的时候看到这个文件包含靶场，因为与PHPMyadmin相关，因此复现一波。</p><h2 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h2><p>漏洞原理涉及到PHP的代码部分出现问题，状态不好暂且跳过（不然怎么叫水文呢），直接进行复现。</p><h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>第一步，进入靶场。不出意外是一个PHPMyAdmin的管理页面，使用root/root弱口令登录到后台。</p><p>第二步，找到相应漏洞复现文章。</p><p>第三步，模仿复现文章进行复现。</p><p>根据题目背景可以知道是文件包含，如果是真实环境……首先得是PHP4.8.0和4.8.1版本，其次，得能登录到后台。</p><p>找到了相应的漏洞之后，按照复现文章进行复现。</p><p>直接快进到利用</p><p>首先在sql中执行语句，比如phpinfo</p><p><img src="1.png" alt="执行语句"></p><p>执行之后找到这个页面要包含的session文件名，在cookie里边可以找到</p><p><img src="2.png" alt="session文件名"></p><p>然后包含，index.php?target=db_sql.php%253f/../../../../../../../../tmp/tmp/sess_8q6a3sanco25u26716p3l1dtofs2r7lc</p><p>可以看到phpinfo包含成功</p><p><img src="3.png" alt="包含成功"></p><p>于是把写进去的语句换成一句话木马。</p><p>然后使用蚁剑连接……很生气，连接不上，浪费我睡觉时间。</p><p>凭借之前做的经验，知道flag在根目录下的key.txt里，爷直接文件包含读取。</p><p>index.php?target=db_sql.php%253f/../../../../../../../../key.txt</p><p><img src="4.png" alt="获取成功"></p><p>搞定睡觉！</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>等之后有空了再来补其他的。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 墨者靶场WP </tag>
            
            <tag> 漏洞复现 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jboss5.x/6.x反序列化漏洞复现</title>
      <link href="/2020/06/10/jbossunseralize/"/>
      <url>/2020/06/10/jbossunseralize/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本来想要复现shiro的反序列化漏洞，实在是太困了，想睡觉……等到周末再进行复线吧。</p><p>这次选择了JBoss的反序列化漏洞，也算是中间件漏洞的一种，依然选择墨者的在线靶场。</p><p>话不多说，直接开始。</p><h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>进入靶场后，访问/invoker/readonly，回显500，证实漏洞确实存在</p><p><img src="1.png" alt="请求的回显"></p><p>这个时候需要用到工具了，可以直接用jboss反序列化漏洞利用工具。</p><p>这里偷个懒，在使用工具之后，检测接着可以直接执行cmd命令。</p><p><img src="2.png" alt="直接使用工具"></p><p>关键是要获取到key，key在根目录下，那直接使用cat读取就可以了。</p><p><img src="3.png" alt="直接获得key"></p><p>该漏洞还有其他利用方式，这个是最简单的，偷个懒，太困了……其他利用方式等周末了补充上来。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>本次漏洞复现的心得：成功下载了jboss反序列化漏洞的利用工具呢。噢还有在linux下启动jar的图形化界面的命令，直接用java -jar就可以了。</p><p>至于写shell什么的，之后再来吧。</p>]]></content>
      
      
      <categories>
          
          <category> 漏洞复现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 墨者靶场WP </tag>
            
            <tag> 中间件漏洞 </tag>
            
            <tag> 漏洞复现 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP缓慢DOS攻击漏洞验证</title>
      <link href="/2020/06/09/httpdos/"/>
      <url>/2020/06/09/httpdos/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>漏洞扫描器中，经常会出现一个HTTP缓慢DOS攻击的漏洞。之前不知该如何验证，也考虑到DOS攻击会使服务器受到影响，一直没有尝试验证。今天学习了一下，稍作记录。</p><h2 id="什么是缓慢DOS攻击"><a href="#什么是缓慢DOS攻击" class="headerlink" title="什么是缓慢DOS攻击"></a>什么是缓慢DOS攻击</h2><p>首先一个点，并非所有的DOS攻击都是以大流量进行攻击，而缓慢DOS攻击中的“慢”，自然相对于这些“快”。</p><p>以我的理解，通俗些来说，就是攻击者向服务器发送多个并发TCP连接。</p><p>服务器是在所有请求被完全接受后才会断开TCP连接，这些连接便以很低的速度发包。于是服务器资源被长期占用，无法处理其他正常用户的请求。自然就达成了DOS攻击的目的。</p><p>且这种攻击模式相对廉价，只需一台普通PC即可，无需传统DOS攻击中需要结合肉鸡群做分布式DOS。</p><h2 id="如何验证"><a href="#如何验证" class="headerlink" title="如何验证"></a>如何验证</h2><p>验证的话一般使用两种方式；</p><blockquote><p>使用nmap脚本</p></blockquote><p>可以使用nmap中的脚本对指定ip进行测试，代码如下：</p><pre><code>nmap -T4 -n -Pn -p [port] -sV -s --script http-slowloris-check [ip]</code></pre><p>一般效果如图：</p><p><img src="1.png" alt="nmap脚本测试"></p><blockquote><p>或者使用专门的大佬脚本工具</p></blockquote><p>kali里边可以直接安装：</p><pre><code>apt-get install slowhttptest</code></pre><p>接着使用该脚本进行测试：</p><pre><code>slowhttptest -c 5000 -u [hostname/ip]</code></pre><p>一般效果如图：</p><p><img src="2.png" alt="脚本测试"></p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>本次漏洞验证到此结束，若有不足之处，还望于评论区中指出，万分感谢！</p>]]></content>
      
      
      <categories>
          
          <category> 漏洞验证 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 漏洞验证 </tag>
            
            <tag> DOS攻击 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>windows、linux下awvs13安装教程（内附资源链接）</title>
      <link href="/2020/06/08/awvs/"/>
      <url>/2020/06/08/awvs/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近HW要开始了，扫描器也得跟上。AWVS用的还是11，觉得不太好用，看到13似乎还不错，就在网上找了资源下载安装。记录一下安装过程。</p><h2 id="删除已安装的AWVS"><a href="#删除已安装的AWVS" class="headerlink" title="删除已安装的AWVS"></a>删除已安装的AWVS</h2><p>首先需要删除原本装的awvs。</p><p>对于windwos系统而言，可以直接安装，覆盖安装即可。</p><p>对于使用linux系统的，则需要先删除home文件下的awvs相关文件夹。</p><p>一般是如下命令：</p><pre><code>rm -rf /home/acunetix/ //使用tab补全即可</code></pre><p>接着删除awvs建立的用户，打开/etc/passwd，找到acunetix，删除即可。</p><h2 id="安装awvs13"><a href="#安装awvs13" class="headerlink" title="安装awvs13"></a>安装awvs13</h2><p>这边先说成功安装的windows版本，首先一键安装，接着将wvsc.exe覆盖到“C:\Program Files (x86)\Acunetix\13.0.200205121\”</p><p>将license_info.json覆盖到“C:\ProgramData\Acunetix\shared\license”即可完成破解。</p><p>对于linux下的安装，进入解压后的目录。使用如下命令赋予文件执行权限：</p><pre><code> chmod +x *</code></pre><p>使用”./acunetix(tab补全)”开始安装。</p><p>这里会进入交互界面，按下Enter后是一长串的协议。可以一直按住回车键往下，也可以直接ctrl+c退出。</p><p>然后输入yes，输入hostname。</p><p>这里就是awvs打开的链接，一般使用127.0.0.1</p><p>接着第二步，填写用来登录的账号和密码。</p><p>填写完成后，开始安装。当安装完成后，使用如下命令进行破解。</p><pre><code> cp -rf wvsc /home/acunetix/.acunetix/v_200217097/scanner/ cp -rf license_info.json /home/acunetix/.acunetix/data/license/</code></pre><p>至此安装破解都完成了，但是我在linux下运行会出现问题，无法新建target。重新安装依然如此，迫于无奈下使用windows版本.</p><p>如有大佬明白原因，还请不吝赐教！</p><p>文章最后附上资源链接，希望大家支持正版（雾）！</p><p>下载地址：</p><p>windows：<a href="https://pan.baidu.com/s/1sPEIXi8XkEGlHhrfPm-KWQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1sPEIXi8XkEGlHhrfPm-KWQ</a>   密码：menp</p><p>Linux：<a href="https://pan.baidu.com/s/1DOlrsXKEsWeYBTx-y5RJlw" target="_blank" rel="noopener">https://pan.baidu.com/s/1DOlrsXKEsWeYBTx-y5RJlw</a> 密码：tv9z</p><p>文章与资源采用均根据这位大佬文章而来：<a href="http://www.manongjc.com/detail/16-mfpdrwztekbjkso.html。" target="_blank" rel="noopener">http://www.manongjc.com/detail/16-mfpdrwztekbjkso.html。</a></p><p>如有侵权，联系后删除。</p>]]></content>
      
      
      <categories>
          
          <category> 安装教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> awvs13 </tag>
            
            <tag> 安装教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IIS漏洞PUT任意文件上传复现</title>
      <link href="/2020/06/07/sort-algorithms/"/>
      <url>/2020/06/07/sort-algorithms/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>因为懒得搭环境，所以直接用了墨者学院的靶场。</p><p>产生PUT任意文件上传的原因在于使用IIS开启了webDAV。问题来了，什么是webDVA？</p><p>简单来说，webDAV是基于HTTP 1.1的通信协议，使得在除了GET、POST、HEAD这几种常见的请求方式之外，还能使用像是PUT、MOVE、COPY这些方法。</p><p>问题就出在了这里，一般的网站根本不需要用到这些多的请求，在开启webDAV、而且还选了可写入这个选项之后，就能造成任意文件上传（伪）。</p><h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><blockquote><p>中间件漏洞</p></blockquote><p>理解差不多的原理之后，再看墨者的这个靶场，使用的是IIS6.0，直接使用OPTIONS方法。如果开启了webDAV的话，OPTIONS方法能够显示支持的请求。</p><p><img src="1.png" alt="OPTIONS请求的回显"></p><p>显然开启了webDAV，那么使用PUT方法上传一句话木马。IIS6.0默认可执行文件为asp，所以使用asp的一句话马。</p><p>为什么说是任意文件上传（伪），因为上传的文件后缀名不能是asp，只能传txt这种。</p><p><img src="2.png" alt="PUT上传文件"></p><p>回显201，显示创造成功。</p><p>但是因为是txt，无法利用。因此使用MOVE或者COPY，将文件移动成asp后缀脚本</p><p>传asp传不上去（图没截），因为环境是IIS6.0，那就用IIS6.0的分号解析漏洞，上传;.txt</p><p><img src="3.png" alt="利用解析漏洞生成可执行文件"></p><p>这里似乎是墨者靶场的回显码有错误。</p><p>如果是自己搭建环境的话，出现了回显207，需要勾选可执行脚本资源这个选项，就能正常利用了。</p><p>访问/shell.asp;.txt，页面虽然空白但证实的确存在，用蚁剑连接，找到key。</p><p><img src="4.png" alt="连接"></p><p>至此复现完成，因能力有限，如果本文中有什么不对之处，烦请读者于评论区中指出错误，谢谢！</p>]]></content>
      
      
      <categories>
          
          <category> 漏洞复现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 墨者靶场WP </tag>
            
            <tag> 中间件漏洞 </tag>
            
            <tag> 漏洞复现 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
